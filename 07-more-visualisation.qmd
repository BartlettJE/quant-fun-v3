# Scatterplots, boxplots, and violin-boxplots {#07-more-viz}

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, 
                      message = FALSE, 
                      echo = TRUE)

```

In this chapter we are going to focus on visualising data using `ggplot2`. You've already created a number of different plots including bar charts, scatterplots, histograms, qq-plots, and violin-boxplots, but now we will show you how to customise your plots further to give you a better idea of the range and flexibility of visualising data in R. 

**Chapter Intended Learning Outcomes (ILOs)**

By the end of this chapter, you will be able to: 

- ILO1.

## Chapter preparation

### Introduction to the data set 

For this chapter, we are using open data from @zhang_present_2014. The abstract of their article is:

> Although documenting everyday activities may seem trivial, four studies reveal that creating records of the present generates unexpected benefits by allowing future rediscoveries. In Study 1, we used a time-capsule paradigm to show that individuals underestimate the extent to which rediscovering experiences from the past will be curiosity provoking and interesting in the future. In Studies 2 and 3, we found that people are particularly likely to underestimate the pleasure of rediscovering ordinary, mundane experiences, as opposed to extraordinary experiences. Finally, Study 4 demonstrates that underestimating the pleasure of rediscovery leads to time-inconsistent choices: Individuals forgo opportunities to document the present but then prefer rediscovering those moments in the future to engaging in an alternative fun activity. Underestimating the value of rediscovery is linked to peopleâ€™s erroneous faith in their memory of everyday events. By documenting the present, people provide themselves with the opportunity to rediscover mundane moments that may otherwise have been forgotten.

In summary, they were interested in whether people could predict how interested they would be in rediscovering past experiences. They call it a "time capsule" effect, where people store photos or messages to remind themselves of past events in the future. 

At the start of the study (time 1), participants in a romantic relationship wrote about two kinds of experiences. An "extraordinary" experience with their partner on Valentine's day and an "ordinary" experience one week before. They were then asked how enjoyable, interesting, and meaningful they predict they will find these recollection in three months time (time 2). Three months later, Zhang et al. randomised participants into one of two groups. In the "extraordinary" group, they reread the extraordinary recollection. In the "ordinary" group, they reread the ordinary recollection. All the participants completed measures on how enjoyable, interesting, and meaningful they found the experience, but this time what they felt, rather than what they predict they will feel. 

They predicted participants in the ordinary group would underestimate their future feelings (i.e., there would be a bigger difference between time 1 and time 2 measures) compared to participants in the extraordinary group. In this chapter, we focus on a composite measure which took the mean of items on interest, meaningfulness, and enjoyment. 

### Organising your files and project for the chapter

Before we can get started, you need to organise your files and project for the chapter, so your working directory is in order.

1. In your folder for research methods and the book `ResearchMethods1_2/Quant_Fundamentals`, create a new folder called `Chapter_07_dataviz`. Within `Chapter_07_dataviz`, create two new folders called `data` and `figures`.

2. Create an R Project for `Chapter_07_dataviz` as an existing directory for your chapter folder. This should now be your working directory.

3. Create a new R Markdown document and give it a sensible title describing the chapter, such as `07 Scatterplots Boxplots Violins`. Delete everything below line 10 so you have a blank file to work with and save the file in your `Chapter_07_dataviz` folder. 

4. We are working with a new data set, so please save the following data file: [Zhang_2014.csv](data/Zhang_2014.csv). Right click the link and select "save link as", or clicking the link will save the files to your Downloads. Make sure that you save the file as ".csv". Save or copy the file to your `data/` folder within `Chapter_07_dataviz`.

You are now ready to start working on the chapter! 

### Activity 1 - Read and wrangle the data

As the first activity, try and test yourself by completing the following task list to practice your data wrangling skills. Create an object called `zhang_data` to be consistent with the tasks below. If you just want to focus on data visualisation, then you can just type the code in the solution. 

::: {.callout-tip}
#### Try this

To wrangle the data, complete the following tasks: 

1. Load the <pkg>tidyverse</pkg> package. 

2. Read the data file `data/Zhang_2014.csv`.

3. Select the following columns: 

    - `Gender`
    
    - `Age`
    
    - `Condition`
    
    - `T1_Predicted_Interest_Composite` renamed to `time1_interest`
    
    - `T2_Actual_Interest_Composite` renamed to `time2_interest`.

4. There is currently no identifier, so create a new variable called `participant_ID`. Hint: try `participant_ID = row_number()`. 

5. Recode two variables to be easier to understand and visualise: 

    - Gender: 1 = "Male", 2 = "Female".
    
    - Condition: 1 = "Ordinary", 2 = "Extraordinary". 

Your data should now be in wide format and ready to create a scatterplot. 
:::

::: {.callout-caution collapse="true"}
#### Show me the solution
You should have the following in a code chunk: 

```{r}
# Load the tidyverse package below
library(tidyverse)

# Load the data file
# This should be the Zhang_2014.csv file 
zhang_data <- read_csv("data/Zhang_2014.csv")

# Wrangle the data for plotting. 
# select and rename key variables
# mutate to add participant ID and recode
zhang_data <- zhang_data %>%
  select(Gender, 
         Age, 
         Condition, 
         time1_interest = T1_Predicted_Interest_Composite, 
         time2_interest = T2_Actual_Interest_Composite) %>%
  mutate(participant_ID = row_number(),
         Condition = case_match(Condition, 
                            1 ~ "Ordinary", 
                            2 ~ "Extraordinary"),
         Gender = case_match(Gender,
                             1 ~ "Male",
                             2 ~ "Female")) 
```

:::

### Activity 2 - Explore the data

::: {.callout-tip}
#### Try this
After the wrangling steps, try and explore `zhang_data` to see what variables you are working with. For example, opening the data object as a tab to scroll around, explore with `glimpse()`, or try plotting some of the individual variables to see what they look like using visualisation skills from Chapter 3. 
:::

In `zhang_data`, we have the following variables:

| Variable       |       Type                       |           Description          |
|:--------------:|:---------------------------------|:-------------------------------|
| Gender | `r typeof(zhang_data$Gender)`| Participant gender: Male (1) or Female (2) |
| Age  | `r typeof(zhang_data$Age)`| Participant age in years. |
| Condition | `r typeof(zhang_data$Condition)`| Condition participant was randomly allocated into: Ordinary (1) or Extraordinary (2). |
| time1_interest | `r typeof(zhang_data$time1_interest)`| How interested they predict they will find the recollection on a 1 (not at all) to 7 (extremely) scale. This measure is the mean of enjoyment, interest, and meaningfulness. |
| time2_interest | `r typeof(zhang_data$time2_interest)`| How interested they actually found the recollection on a 1 (not at all) to 7 (extremely) scale. This measure is the mean of enjoyment, interest, and meaningfulness. |
| participant_ID | `r typeof(zhang_data$participant_ID)`| Our new participant ID as an integer from 1 to 130. |

We will use this data set to demonstrate different ways of visualising continuous variables, either combining multiple continuous variables in a scatterplot or splitting continuous variables into categories in a boxplot or violin-boxplot. 

## Scatterplots {#viz-a3}

The first visualisation is a `r glossary("scatterplot", def = "Plotting two variables on the x- and y-axis to show the correlation/relationship between the variables.")` to show the relationship between two continuous variables. One variable goes on the x-axis and the other variables goes on the y-axis. Each dot then represents the intersection of those two variables. You will use these plots when reporting a correlation or regression. 

### Activity 3 - Creating a basic scatterplot

Now let us make a scatterplot plotting `Age` and `time1_interest` to see if there is any relationship between the two. We need to specify both the x- and y-axis variables, but the only difference to what we created in Chapter 3 is using a new layer `geom_point`. 

```{r scat1}
zhang_data %>% 
  ggplot(aes(x = time1_interest, y = Age)) +
       geom_point()
```

### Activity 4 - Editing axis labels

This plot is great for some exploratory data analysis, but it looks a little untidy to put into a report. We can use the `scale_x_continuous` and `scale_y_continuous` layers to control the tick marks, as well as the axis name. 

```{r scat2}
zhang_data %>%  
  ggplot(aes(x = time1_interest,y = Age)) +
  geom_point() +
  theme_classic() + 
  scale_x_continuous(name = "Time 1 interest score (1-7)", 
                     breaks = c(1:7)) + # tick marks from 1 to 7
  scale_y_continuous(name = "Age",
                     limits = c(15, 45), # change limits to 15 to 45
                     breaks = seq(from = 15, # sequence from 15
                                  to = 45, # to 45 
                                  by = 5)) # in steps of 5
```

To break down these new function layers: 

- `breaks` set the tick marks on the plot. We demonstrate two ways of setting this. On the x-axis, we just manually set values for 1 to 7. On the y-axis, we use a second function to set the breaks. 

- `seq()` creates a sequence of numbers and can save a lot of time when you need to add lots of values. We set three arguments, `from` for the starting point, `to` for the end point, and `by` for the steps the sequence goes up in. 

- `limits` controls the start and end point of the graph scale. In the original graph, we can see there are points below 20 and above 40, so we might want to increase the `limits` of the graph to include a wider range. 

::: {.callout-important}
#### Error mode

When controlling the limits of the graph, sometimes you want to decrease the `limits` range to zoom in on an element of the data. If you decrease the range which cuts off some data points, you must be very careful as it actually cuts off data which you would receive a warning about:

```{r warning=TRUE}
zhang_data %>%  
  ggplot(aes(x = time1_interest,y = Age)) +
  geom_point() +
  theme_classic() + 
  scale_y_continuous(name = "Age",
                     limits = c(30, 40)) # in steps of 5
```

You must be very careful when truncating axes, but if you *do* need to do it, there is a different function layer to use: 

```{r}
zhang_data %>%  
  ggplot(aes(x = time1_interest,y = Age)) +
  geom_point() +
  theme_classic() + 
  coord_cartesian(ylim = c(30, 40))
```

:::

### Activity 5 - Adding a regression line

It is often useful to add a regression line or line of best fit to a scatterplot. You can add a regression line with the `geom_smooth()` layer and by default will also provide a 95% confidence interval. You can specify what type of line you want to draw, most often you will need `method = lm` for a linear model or a straight line. 

```{r scat3}
zhang_data %>%  
  ggplot(aes(x = time1_interest,y = Age)) +
  geom_point() +
  theme_classic() + 
  scale_x_continuous(name = "Time 1 interest score (1-7)", 
                     breaks = c(1:7)) + # tick marks from 1 to 7
  scale_y_continuous(name = "Age",
                     limits = c(15, 45), # change limits to 15 to 45
                     breaks = seq(from = 15, # sequence from 15
                                  to = 45, # to 45 
                                  by = 5)) +  # in steps of 5
  geom_smooth(method = "lm")
```

With the regression line, we can see there is very little relationship between age and interest score at time 1. 

::: {.callout-tip}
#### Try this

So far, we made a scatterplot of age against interest at time 1. Now, create a scatterplot on your own using the two interest rating variables: `time1_interest` and `time2_interest`. 

After you made the scatterplot, it looks like there is a `r mcq(c(answer = "positive", "negative"))` relationship between interest ratings at time 1 and time 2. 
:::

::: {.callout-caution collapse="true"}
#### Show me the solution
You should have the following in a code chunk: 

```{r}
zhang_data %>%  
  ggplot(aes(x = time1_interest, y = time2_interest)) +
  geom_point() +
  theme_classic() + 
  scale_x_continuous(name = "Time 1 interest score (1-7)", 
                     breaks = c(1:7)) + # tick marks from 1 to 7
  scale_y_continuous(name = "Time 2 interest score (1-7)", 
                     breaks = c(1:7)) + # tick marks from 1 to 7
  geom_smooth(method = "lm")
```

:::

### Activity 6 - Creating a grouped scatterplot

Before we move on, we can add a third variable to show how the relationship might differ for different groups within our data. We can do this by adding the `colour` argument to `aes()` and setting it as whatever variable we would like to distinguish between. In this case, we will see how the relationship between age and interest at time 1 differs for the male and female participants. There are a few participants with missing gender, so we will first filter them out.


```{r, scat4, fig.cap = "Grouped scatterplot", warning=FALSE}
zhang_data %>%
  drop_na(Gender) %>% 
  ggplot(aes(x = time1_interest, y = Age, colour = Gender)) +
  geom_point() +
  theme_classic() + 
  scale_x_continuous(name = "Mean interest score (1-7)",
                     breaks = c(1:7)) + 
  scale_y_continuous(name = "Age") +
  geom_smooth(method = "lm")
```

::: {.callout-tip}
#### Try this

For your independent scatterplot of the two interest rating variables: `time1_interest` and `time2_interest`, add a `colour` argument using the `Condition` variable. This will show the relationship between time 1 and time 2 interest separately for participants in the ordinary and extraordinary groups. 

:::

::: {.callout-caution collapse="true"}
#### Show me the solution
You should have the following in a code chunk: 

```{r}
zhang_data %>%  
  ggplot(aes(x = time1_interest, y = time2_interest, colour = Condition)) +
  geom_point() +
  theme_classic() + 
  scale_x_continuous(name = "Time 1 interest score (1-7)", 
                     breaks = c(1:7)) + # tick marks from 1 to 7
  scale_y_continuous(name = "Time 2 interest score (1-7)", 
                     breaks = c(1:7)) + # tick marks from 1 to 7
  geom_smooth(method = "lm")
```

:::

## Boxplots {#viz-a4}

The next visualisation is the `r glossary("boxplot", def = "Visualising a continuous variable by five summary statistics: the median centre line, the first and third quartile, and 1.5 times the first and third quartiles.")` which presents a range of summary statistics for your outcome, which you can split between different groups on the x-axis, or add further variables to divide by. For the boxplot element, you get five summary statistics: the median centre line, the first and third quartile as the box (essentially, the interquartile range), and 1.5 times the first and third quartiles as the whiskers extending from the box.  

### Activity 7 - Creating a basic boxplot

Before we create the boxplot, we need a final data wrangling step. At the moment, we have `time1_interest` and `time2_interest` in wide format, but to plot together, we need to express it as a single variable. For that, we must restructure the data. 

::: {.callout-tip}
#### Try this

To wrangle the data, gather the variables `time1_interest` and `time2_interest`. Create a new object called `zhang_data_long` and use the names `Time` and `Interest` for your column names to be consistent with the demonstrations below.

:::

::: {.callout-caution collapse="true"}
#### Show me the solution
You should have the following in a code chunk: 

```{r}
# gather the data to convert to long format
zhang_data_long <- zhang_data %>% 
  pivot_longer(cols = time1_interest:time2_interest,
               names_to = "Time",
               values_to = "Interest")
```
:::


If you only want to visualise one continuous variable, we need one variable on the y-axis and a new function layer `geom_boxplot()`. 

```{r bp1}
zhang_data_long %>% 
  ggplot(aes(y = Interest)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7))
```

Typically, you want to compare the outcome between one or more categories, so we can add a categorical variable like gender to the x-axis, removing the missing value first. 

```{r}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  ggplot(aes(y = Interest, x = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7))
```

### Activity 8 - Adding colour to variables

It is not as important when you only have one variable on the x-axis, but one useful feature is adding colour to distinguish between categories. You can control this by adding a variable to the `fill` argument within `aes()`. 

By default, we get a legend which is redundant when we only have different colours on the x-axis, so we can turn it off by adding `guides(fill = FALSE)` as a layer. 

```{r bp4, fig.cap = "Boxplot with colour"}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  ggplot(aes(y = Interest, x = Gender, fill = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  guides(fill = FALSE) # remove the legend
```

::: {.callout-important}
#### Error mode

You might have noticed we have now used two different arguments to control the colour. In scatterplots, we used `colour`. In boxplots, we used `fill`. It is one of those concepts that takes time to recognise which you need, depending on the type of geoms you are using. Roughly, `colour` is when you want to control the outline or symbol, like the points. Whereas `fill` is when you want the inside of a geom coloured. You can see the difference here by controlling `fill` first:  

```{r}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  ggplot(aes(y = Interest, x = Gender, fill = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7))
```

Then `colour`: 

```{r}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  ggplot(aes(y = Interest, x = Gender, colour = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7))
```

:::

### Activity 9 - Controlling colours

<pkg>ggplot2</pkg> has a default colour scheme which is fine for quick plots, but it is useful to control the colour scheme. You can do this manually by editing `scale_fill_discrete()` and choosing colours through the `type` argument (you can do this through character names or choosing a HEX code: [https://r-charts.com/colors/](https://r-charts.com/colors/){target="_blank"}). 

```{r}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  ggplot(aes(y = Interest, x = Gender, fill = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  scale_fill_discrete(type = c("blue", "pink"))
```

Alternatively, can use `scale_fill_viridis_d()`. This function does exactly the same thing but it uses a colour-blind friendly palette (which also prints in black and white). There are 5 different options for colours and you can see them by changing `option` to A, B, C, D or E. We like option E with `alpha = .6` (to control transparency and soften the tone) but play around with the options to see what you prefer.

```{r, fig.cap= "Boxplots with friendly colours"}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  ggplot(aes(y = Interest, x = Gender, fill = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  scale_fill_viridis_d(option = "E", 
                       alpha = 0.6) + 
  guides(fill = FALSE)
```

::: {.callout-tip}
#### Try this

For your independent boxplot, use `zhang_data_long` to visualise `Interest` as your continuous variable and `Condition` for different categories. This will show the difference in interest rating between those in the ordinary and extraordinary groups. 
:::

::: {.callout-caution collapse="true"}
#### Show me the solution
You should have the following in a code chunk: 

```{r}
zhang_data_long %>% 
  ggplot(aes(y = Interest, x = Condition, fill = Condition)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  scale_fill_viridis_d(option = "E", 
                       alpha = 0.6) + 
  guides(fill = FALSE)
```

:::

### Activity 10 - Ordering categories

When we plot variables like `Gender` on the x-axis, R has an internal order it sets unless you create a factor. The default is alphabetical or numerical. In previous plots, it displayed Female then Male, as F comes before M. 

Controlling the order of categories is an important design choice to communicate your message, and the most direct way is controlling the factor order before plotting. Here, we add `mutate()` in a pipe and manually set the factor levels, just be careful as it is case sensitive to the values in your data. 

```{r}
zhang_data_long %>% 
  drop_na(Gender) %>% 
  mutate(Gender = factor(Gender, 
                         levels = c("Male", "Female"))) %>% 
  ggplot(aes(y = Interest, x = Gender, fill = Gender)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  scale_fill_viridis_d(option = "E", 
                       alpha = 0.6) + 
  guides(fill = FALSE)
```


### Activity 11- Boxplots for multiple factors

When you only have one independent variable, using the `fill` argument to change the colour can be a little redundant as the colours do not add any additional information. It makes more sense to use colour to represent a second variable. 

For this example, we will use `Condition` and `Time` as variables. `fill()` now specifies a second independent variable, rather than repeating the variable on the x-axis as in the previous plot, so we do not want to deactivate the legend. 

```{r bp5, fig.cap = "Boxplot for two factors"}
zhang_data_long %>% 
  ggplot(aes(y = Interest, x = Condition, fill = Time)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  scale_fill_viridis_d(option = "E", 
                       alpha = 0.6)
```

As a final point here, the `fill` values on the legend are not the most professional looking. Like reordering factors, the easiest way of addressing this is editing the underlying data before piping to <pkg>ggplot2</pkg>. 

```{r}
zhang_data_long %>% 
  mutate(Time = case_match(Time,
                           "time1_interest" ~ "Time 1",
                           "time2_interest" ~ "Time 2")) %>% 
  ggplot(aes(y = Interest, x = Condition, fill = Time)) +
  geom_boxplot() + 
  scale_y_continuous(name = "Interest score (1-7)", 
                     breaks = c(1:7)) + 
  scale_fill_viridis_d(option = "E", 
                       alpha = 0.6)
```


## Violin-boxplots {#viz-a7}

### Basic violin plot

Violin plots are so-called because with a normal distribution the shape would look something like a violin. They show density, i.e., the fatter the violin the more data points there are for that value.

```{r vp1, fig.cap = "Basic violin plot"}
ggplot(zhang_data_long, aes(x = Condition, y = Interest))+
  geom_violin()
```

### Violin plots with raw data points

Like the boxplot, we can also add the raw data points to our violin plot, making sure to use jitter  to avoid over-plotting.

```{r vp2, fig.cap = "Violin plot with data points"}
ggplot(zhang_data_long, aes(x = Condition, y = Interest))+
  geom_violin()+
  geom_jitter(height = 0, width = .1)
```

```{block, type="warning"}
It's important to remember that R is very literal. `ggplot2` works on a system of layers. It will add new geoms on top of existing ones and it won't stop to think whether this is a good idea. Try running the above code but put `geom_jitter()` first and then add `geom_violin()`. The order of your layers matters.
```

## Activity 8: Violin-boxplots {#viz-a8}

One increasingly common graph is a violin + boxplot + summary plot that shows a huge amount of information about your data in a single plot. 

* This code uses two calls to `stat_summary()` that was introduced during the t-test chapter. The first draws a `point` to represent the mean, and the second draws an `errorbar` that represents standard error (`mean_se`).  
* `guides` is a new function and can be used to adjust whether legends are displayed. This has the same effect as specifying `show.legend = FALSE` in both `geom_violin()` and `geom_boxplot()` but it uses less code to do so.  
* `fatten = NULL` removes the median line from the boxplots. This can be useful if you're running a test where you're comparing means as it makes it easier to see the point range. 
* You may get warning messages telling you that R has removed rows containing missing values, you do not need to worry about this.

```{r vbp1, fig.cap = "Violin-boxplot with summary data"}
ggplot(zhang_data_long, aes(x = Condition, y = Interest, fill = Condition))+
  geom_violin(alpha = .6, trim = FALSE)+
  geom_boxplot(width = .2, alpha = .7, fatten = NULL)+
  stat_summary(fun = "mean", geom = "point") +
  stat_summary(fun.data = "mean_se", geom = "errorbar", width = .1) +
  scale_fill_viridis_d(option = "E", label = c("Ordinary", "Extraordinary"))+
  scale_y_continuous(name = "Mean interest rating (1-7)") +
  guides(fill = FALSE)

```

## Activity 9: Faceting {#viz-a9}

`ggplot2` contains a facet function that produces different plots for each level of a grouping variable which can be very useful when you have more than two factors, for example, for a three-way ANOVA. The following code displays produces violin-boxplots for Condition ~ interest, but separately for male and female participants. 

* This code adds an extra argument `position = position_dodge(.9)` to align the layers with the violin plots. Try removing this argument from each layer to see what happens, and also try adjusting the value from `.9` to another number.

```{r facet1, fig.cap = "Violin-boxplot facetted by gender", message = FALSE}
ggplot(zhang_data_long, aes(x = Condition, y = Interest, fill = Time))+
  geom_violin(alpha = .6, trim = FALSE)+
  geom_boxplot(width = .2, 
               alpha = .6, 
               fatten = NULL,
               position = position_dodge(.9))+
  stat_summary(fun = "mean", geom = "point",
               position = position_dodge(.9)) +
  stat_summary(fun.data = "mean_se", geom = "errorbar", width = .1,
               position = position_dodge(.9))+
  scale_fill_viridis_d(option = "E") +
  facet_wrap(~Gender)
```

### Facet labelling

Finally, changing the labels within the facets is a little more complicated - there's no additional scale layer, instead, you adjust this inside `facet_wrap()` using `labeller`. This has always felt unintuitive to me and I have to look it up every single time so don't worry if it is confusing - just remember where to look for the example. 

```{r facet2, fig.cap = "Facetted plot with updated labels"}
ggplot(zhang_data_long, aes(x = Condition, y = Interest, fill = Time))+
  geom_violin(alpha = .6, trim = FALSE)+
  geom_boxplot(width = .2, 
               alpha = .6, 
               fatten = NULL,
               position = position_dodge(.9))+
  stat_summary(fun = "mean", geom = "point",
               position = position_dodge(.9)) +
  stat_summary(fun.data = "mean_se", geom = "errorbar", width = .1,
               position = position_dodge(.9))+
  scale_fill_viridis_d(option = "E") +
  facet_wrap(~Gender, labeller = labeller(Gender = (c(female = "Female", male = "Male"))))
```

## Test yourself

To end the chapter, we have some knowledge check questions to test your understanding of the concepts we covered in the chapter. We then have some error mode tasks to see if you can find the solution to some common errors in the concepts we covered in this chapter. 

### Knowledge check

**Question 1**. We have...

`r longmcq(sample(c("select()", answer="filter()", "mutate()", "arrange()", "group_by()", "summarise()")))`

**Question 2**. We are...

`r longmcq(sample(c("select()", "filter()", "mutate()", "arrange()", "group_by()", answer="summarise()")))`

**Question 3**. Our data..

`r longmcq(sample(c("select()", "filter()", answer="mutate()", "arrange()", "group_by()", "summarise()")))`

**Question 4**. We want...

`r longmcq(sample(c(answer="group_by() and summarise()", "filter() and select()", "group_by() and arrange()", "arrange() and mutate()")))` 

**Question 5**. If we...

`r longmcq(sample(c(answer = "wide_data %>% select() %>% pivot_longer() %>% group_by() %>% summarise()", "long_data %>% select() %>% pivot__longer_wider() %>% group_by() %>% summarise()", "wide_data %>% pivot_longer() %>% select() %>% summarise() %>% group_by()", "select() %>% pivot_longer() %>% group_by() %>% summarise() %>% wide_data")))`

### Error mode

The following questions are designed to introduce you to making and fixing errors. For this topic, we focus on the new types of data visualisation. Remember to keep a note of what kind of error messages you receive and how you fixed them, so you have a bank of solutions when you tackle errors independently. 

Create and save a new R Markdown file for these activities. Delete the example code, so your file is blank from line 10. Create a new code chunk to load <pkg>tidyverse</pkg> and the data files: 

```{r eval=FALSE}
# Load the tidyverse package below
library(tidyverse)

# Load the data file
# This should be the Zhang_2014.csv file 
zhang_data <- read_csv("data/Zhang_2014.csv")
```

Below, we have several variations of a code chunk error or misspecification. Copy and paste them into your R Markdown file below the code chunk to load <pkg>tidyverse</pkg> and the data files. Once you have copied the activities, click knit and look at the error message you receive. See if you can fix the error and get it working before checking the answer.

**Question 6**. Copy the following code chunk into your R Markdown file and press knit. 

tick marks, limits

````{verbatim, lang = "markdown"}
```{r}

```
````

::: {.callout-caution collapse="true"} 
#### Explain the solution


```{r eval = FALSE}

```
:::

**Question 7**. Copy the following code chunk into your R Markdown file and press knit. 

combination of pipes and + in ggplot2

````{verbatim, lang = "markdown"}
```{r}

```
````

::: {.callout-caution collapse="true"} 
#### Explain the solution


```{r eval = FALSE}

```
:::

**Question 8**. Copy the following code chunk into your R Markdown file and press knit.

````{verbatim, lang = "markdown"}
```{r}

```
````

::: {.callout-caution collapse="true"} 
#### Explain the solution

```{r eval = FALSE}

```
:::

## Words from this Chapter

Below you will find a list of words that were used in this chapter that might be new to you in case it helps to have somewhere to refer back to what they mean. The links in this table take you to the entry for the words in the [PsyTeachR Glossary](https://psyteachr.github.io/glossary/){target="_blank"}. Note that the Glossary is written by numerous members of the team and as such may use slightly different terminology from that shown in the chapter.

```{r gloss, echo=FALSE, results='asis'}
glossary_table()
```

## End of chapter

Blah. 

