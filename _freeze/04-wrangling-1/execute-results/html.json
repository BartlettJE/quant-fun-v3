{
  "hash": "80de1f7e123725de24f6b3b9f80955a0",
  "result": {
    "engine": "knitr",
    "markdown": "# Data wrangling 1: Join, select, and mutate {#04-wrangling-1}\n\n\n\n\n\nIn this chapter, we start our exploration of <a href='https://psyteachr.github.io/glossary/d#data-wrangling' target='_blank' class='glossary' title='The process of preparing data for visualisation and statistical analysis.'>data wrangling</a>. Some of you might have experience painstakingly copying and pasting values into new columns or trying to match up values from multiple spreadsheets. As well as taking a long time, there is so much room for error as you might repeat or miss values. \n\nWe have mentioned a few times now the benefits of working with R/RStudio to develop reproducible research practices over the first few chapters.But, if you take nothing else away from these materials, developing your data wrangling skills is one of the primary benefits that will benefit you in many assessments and careers.\n\nResearchers actually spend far more of their time cleaning and preparing their data than they spend analysing it. @dasu2003 estimated that up to 80% of time spent on data analysis involves data preparation tasks! Although every data set presents unique challenges, there are some systematic principles that you will constantly use to make your analyses less error-prone and more efficient. Our mantra is: the data changes but the skills stay the same. \n\nOver the next three chapters, we are going to introduce you to a range of functions within the `tidyverse` for wrangling data. In this chapter, we will cover joining two data sets by a common identifier, selecting columns to simplify your data, arranging values within a data set, and mutating data to create new variables.   \n\n**Chapter Intended Learning Outcomes (ILOs)**\n\nBy the end of this chapter, you will be able to: \n\n- ILO1\n\n## Chapter preparation\n\n### Introduction to the data set \n\nFor this chapter, we are using open data from @woodworth_data_2018 one more time. In the last two chapters, we asked you to trust us and copy some code until we reached data wrangling, and now is the time to fill in those gaps. If you need a reminder, the abstract of their article is: \n\n> We present two datasets. The first dataset comprises 992 point-in-time records of self-reported happiness and depression in 295 participants, each assigned to one of four intervention groups, in a study of the effect of web-based positive-psychology interventions. Each point-in-time measurement consists of a participant’s responses to the 24 items of the Authentic Happiness Inventory and to the 20 items of the Center for Epidemiological Studies Depression (CES-D) scale. Measurements were sought at the time of each participant’s enrolment in the study and on five subsequent occasions, the last being approximately 189 days after enrolment. The second dataset contains basic demographic information about each participant.\n\nIn summary, we have one data set containing demographic information about participants and a second data set containing measurements of two scales on happiness and depression. \n\n### Organising your files and project for the chapter\n\nBefore we can get started, you need to organise your files and project for the chapter, so your working directory is in order.\n\n1. In your folder for research methods and the book `ResearchMethods1_2/Quant_Fundamentals`, create a new folder called `Chapter_04_06_datawrangling`. As we are spending three chapters on data wrangling, we will work within one folder. Within `Chapter_04_06_datawrangling`, create two new folders called `data` and `figures`.\n\n2. Create an R Project for `Chapter_04_06_datawrangling` as an existing directory for your chapter folder. This should now be your working directory.\n\n3. We will work within one folder, but create a new R Markdown for each chapter. Create a new R Markdown document and give it a sensible title describing the chapter, such as `04 Data Wrangling 1`. Delete everything below line 10 so you have a blank file to work with and save the file in your `Chapter_04_06_datawrangling` folder. \n\n4. If you already have the two files from chapter 3, copy and paste them into the `data/` folder. If you need to download them again, the links are data file one ([ahi-cesd.csv](data/ahi-cesd.csv)) and data file two ([participant-info.csv](data/participant_info.csv)). Right click the links and select \"save link as\", or clicking the links will save the files to your Downloads. Make sure that both files are saved as \".csv\". Save or copy the file to your `data/` folder within `Chapter_04_06_datawrangling`.\n\nYou are now ready to start working on the chapter! \n\n::: {.callout-note collapse=\"true\"}\n#### Reminder of file management if you use the online server\nIf we support you to use the online University of Glasgow R Server, working with files is a little different. If you downloaded R / RStudio to your own computer or you are using one of the library/lab computers, please ignore this section. \n\n1. Log on to the **R server** using the link we provided to you.\n\n2. In the file pane, click `New folder` and create the same structure we demonstrated above.\n\n3. Download these two data files which we used in Chapter 3. Data file one: [ahi-cesd.csv](data/ahi-cesd.csv). Data file two: [participant-info.csv](data/participant_info.csv). Save the two files into the `data` folder you created for chapter 3. To download a file from this book, right click the link and select \"save link as\". Make sure that both files are saved as \".csv\". Do not open them on your machine as often other software like Excel can change setting and ruin the files.\n\n4. Now that the files are stored on your computer, go to RStudio on the server and click `Upload` then `Browse` and choose the folder for the chapter you are working on.\n\n5. Click `Choose file` and go and find the data you want to upload.\n:::\n\n### Activity 1 - Load `tidyverse` and read the data files\n\nAs the first activity, try and test yourself by loading `tidyverse` and reading the two data files. As a prompt, save the data files to these two object names to be consistent with the activities below, but you can check your answer below if you are stuck. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load the tidyverse package below\n\n# Load the two data files\n# This should be the ahi-cesd.csv file \ndat <- NULL\n\n# This should be the participant-info.csv file\npinfo <- NULL\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Show me the solution\nYou should have the following in a code chunk: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load the tidyverse package below\nlibrary(tidyverse)\n\n# Load the two data files\n# This should be the ahi-cesd.csv file \ndat <- read_csv(\"data/ahi-cesd.csv\")\n\n# This should be the participant-info.csv file\npinfo <- read_csv(\"data/participant-info.csv\")\n```\n:::\n\n\n:::\n\n## Tidyverse and the dplyr package\n\nSo far, we have loaded a <a href='https://psyteachr.github.io/glossary/p#package' target='_blank' class='glossary' title='A group of R functions.'>package</a> called `tidyverse` in every chapter and it is going to be at the core of all the data skills you develop. The `tidyverse` [https://www.tidyverse.org/](https://www.tidyverse.org/){target=\"_blank\"} [@tidyverse] is an ecosystem containing six core packages: `dplyr`, `tidyr`, `readr`, `purrr`,  `ggplot2`, and `tibble`. Within these six core packages, you have access to <a href='https://psyteachr.github.io/glossary/f#function' target='_blank' class='glossary' title='A named section of code that can be reused.'>functions</a> that will pretty much cover everything you need to wrangle and visualise your data. \n\nIn chapter 3, we introduced you to the package `ggplot2` for data visualisation. In this chapter, we focus on functions from the [`dplyr`](https://dplyr.tidyverse.org/){target=\"_blank\"} package, which the authors describe as a grammar of data manipulation (in the wrangling sense, not deviously making up data). \n\nThe `dplyr` package contains several key functions based on common English verbs to help you understand what the code is doing. For an overview, we will introduce you to the following functions:\n\n|Function|Description|\n|:------:|:----------|\n|`*_join()`| Add columns from two data sets by matching observations|\n|`select()`| Include or exclude certain variables (columns)|\n|`mutate()`| Create new variables (columns)|\n|`arrange()`| Change the order of observations (rows)|\n|`filter()`| Include or exclude certain observations (rows)|\n|`group_by()`| Organize the observations (rows) into groups|\n|`summarise()`| Create summary variables for groups of observations|\n\nJust looking at the names gives you some idea of what the functions do. For example, `select()` selects columns and `arrange()` orders observations. You will be surprised by how far you can get with data wrangling using just these functions. There will always be unique problems to solve, but these functions cover the most common that apply to almost every data set. \n\nIn this chapter, we focus on the `*_join()` series of functions, `select()`, `arrange()`, and `mutate()`.\n\n## Joining two data frames with `*_join()` functions\n\nThe first thing we will do is combine data files. We have two files, `dat` and `pinfo`, but what we really want is a single file that has both the happiness and depression scores and the demographic information about the participants as it makes it easier to work with the combined data. \n\nTo do this, we are going to use the function `inner_join()`. So far, we have described these types of functions as `*_join()`. This is because there are a series of functions that join two data sets in slightly different ways. You do not need to memorise these, but it might be useful to refer back to later. \n\n|Join function|Description|\n|:------:|:----------|\n|`inner_join()`| Keep observations in data set 1 that has a matching key in data set 2 |\n|`left_join()`| Keep all observations in data set 1 |\n|`right_join()`| Keep all observations in data set 2 |\n|`full_join()`| Keep all observations in both data set 1 and 2 |\n\n::: {.callout-important}\nAs these functions join data sets in different ways, they will produce different sample sizes depending on the presence of missing data in one or both data sets. For example, `inner_join()` will be the strictest as you must have matching observations in each data set. On the other hand, `full_join()` will be the least strict, as you retain observations that may not exist in one data set or the other. \n:::\n\n### Activity 2 - Join the files together\n\nWe are going to join `dat` and `pinfo` by common identifiers. When we use `inner_join()`, this means we want to keep all the observations in `dat` that also has a corresponding identifier in `pinfo`. This is known as an **<a href='https://psyteachr.github.io/glossary/i#inner-join' target='_blank' class='glossary' title='A mutating join that returns all the rows that have a match in the other table.'>inner-join</a>**, where you would exclude participants if they did not have a matching observation in one of the data sets.\n\nThe code below will create a new object, called `all_dat`, that combines the data from both `dat` and `pinfo` using the information in the columns `id` and `intervention` to match the participants' data across the two sets of data. `id` is a code or number for each unique participant and will be the most common approach you see for creating an identifier. `intervention` is the group the participant was placed in for the study by @woodworth_data_2018. \n\nType and run the code in a new code chunk to inner join the two sets of data.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall_dat <- inner_join(x = dat, \n                      y = pinfo, \n                      by = c(\"id\", \"intervention\"))\n```\n:::\n\n\nTo break down what this code is doing: \n\n- `all_dat` is the new object you created with the joined data. \n\n- `x` is the first argument and it should be the first data set / object you want to combine.\n\n- `y` is the second argument and it should be the second data set / object you want to combine.\n\n- `by` is the third argument and it lists the identifier as the name(s) of the column(s) you want to combine the data by in quote marks. In this scenario, there are two identifiers common to each data set. They both contain columns called \"id\" and \"intervention\". We have to wrap them in `c()` to say that there is more than one column to combine by. If there was only one common identifier, you would write `by = \"id\"`. \n\n::: {.callout-important}\n#### Why does my data include .x and .y columns?\n\nIf your data sets have more than one common column, you must enter them all in the `by` argument. This tells R there are matching columns and values across the data sets. If you do not enter all the common columns, then R will add on a .x and .y when it adds them together, to label which come from each data set.\n\nFor example, try and run this code and look at the columns in `all_dat2`. You will see it has an extra column compared to `all_dat` as there is both \"intervention.x\" and \"intervention.y\". \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall_dat2 <- inner_join(x = dat, \n                      y = pinfo, \n                      by = \"id\")\n```\n:::\n\n:::\n\nOnce you have run this code you should now see the `all_dat` in the environment pane. View the new dataset using one of the methods from Activity 4. In fact, try to remember that you should always view any new object or data that you create. Code often can run but that doesn't necessarily mean it is correct. The programme only ever knows what the code says not what you thought you said. Get into the habit of always checking output!\n\n## Selecting variables of interest with `select()`\n\n## Arranging variables of interest with `arrange()`\n\n## Creating or modifying variables with `mutate()`\n\n## Six functions for wrangling the `babynames`\n\nOk so now we have a fairly code understanding of the babynames, let's use it to learn a bit more about the six functions from `dplyr` that make up a lot of data wrangling!\n\n### Activity 4: Selecting variables of interest  with `select()` {#dw1-a4}\n\nOften data has a lot of variables we don't need and it can be easier to focus on just the data we do need. In `babynames` there are two numeric measurements of name popularity - `prop`, the proportion of all babies with each name, is probably more useful than `n`, the total number of babies with that name, because `prop` takes into account that different numbers of babies are born in different years. \n\nNow as we saw previously, if we wanted to create a dataset that only includes certain variables, we can use the `select()` function from the `dplyr` package. \n\n* In a new code chunk, type and run the below code to select only the columns `year`, `sex`, `name` and `prop` and store it as a `tibble` in the object named `babynames_reduced`.\n    * the first argument `.data` is the object we want to select variables from, in this case `babynames`\n    * the additional arguments are the names of the variables you want to **keep**!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames_reduced1 <- select(.data = babynames,\n                            year, \n                            sex, \n                            name, \n                            prop)\n```\n:::\n\n\nAlternatively, you can also state which variables you don't want to keep! This is really handy if you want to keep a lot of columns and only get rid of maybe one or two. \n\n* Type and run in the below code in a new code chunk.\n    * Here, rather than stating you want to keep `year`, `sex`, `name` and `prop`, we can say drop (i.e. get rid of) the column `n` using the minus sign `-` before the variable name.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames_reduced2 <- select(.data = babynames, \n                             -n)\n```\n:::\n\n\n**Note** that `select()` does not change the original tibble, `babynames`, but makes a new object that stores a new tibble with the specified columns, i.e. `babynames_reduced1` and `babynames_reduced2`. You will see the new objects in your environment pane. If you don't save the new tibbles to an object, they won't be saved. For example, the below code does the same as the previous code but is not saved as the output of the function is not assigned (using the <a href='https://psyteachr.github.io/glossary/a#assignment-operator' target='_blank' class='glossary' title='The symbol &lt;-, which functions like = and assigns the value on the right to the object on the left'>assignment operator</a>, `<-`) to a new object. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nselect(.data = babynames, \n       -n)\n```\n:::\n\n\n### Activity 5: Arranging the data with `arrange()` {#dw1-a5}\n\nSuperb! We now know how to select variables. Another handy skill is being able to change the order of data in a tibble. The function `arrange()` will sort the rows in the table according to the columns you supply. \n\n* Type and run the below code in a new code chunk.\n    * the first argument `.data` again says what object to work on\n    * the second argument says what column to sort the data by - in this instance we are sorting by `name`\n    * the default sorting order is ascending!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsort_asc <- arrange(.data = babynames,\n                    name)\n```\n:::\n\n\nIf you look in `sort_asc` the data are now sorted in ascending alphabetical order by name. But what if you want the data in descending order? Here we can wrap the name of the variable in the `desc()` function. \n\n* Type and run the below code in a new code chunk. When you have run the code have a look at `sort_desc` and note that the data is now sorted by descending year!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsort_desc <- arrange(babynames, \n                     desc(year)) \n```\n:::\n\n\nFinally, you can also sort by more than one column and a combination of ascending and descending columns. Have a look at th below code and then answer the question below:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\narrange(babynames, \n        desc(year), \n        desc(sex), \n        desc(prop)) \n```\n:::\n\n\nThe above code will produce: <div class='webex-radiogroup' id='radio_BXSWYLAFJY'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_BXSWYLAFJY\" value=\"\"></input> <span>the data sorted by descending year and sex but ascending prop</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_BXSWYLAFJY\" value=\"\"></input> <span>the data sorted by descending year and prop but ascending sex</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_BXSWYLAFJY\" value=\"answer\"></input> <span>the data sorted by descending year, sex and prop</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_BXSWYLAFJY\" value=\"\"></input> <span>the data sorted by ascending year, sex and prop</span></label></div>\n\n\n\n<div class='webex-solution'><button>Explain this answer</button>\n\nAs all the columns stated are wrapped in the `desc()` function inside the `arrange()` function then all columns will be sorted in descending fashion, sorting the year first, then the sex, then the prop. Note however that the output is not being stored at all in a new object so you would not be able to work on the data later without saving it in an object first!\n\n</div>\n\n\n### Activity 7: Creating new variables with `mutate()` {#dw1-a7}\n\nDoing really well! Only a little more to go we promise! OK so we have really learnt a lot about changing the data we have but sometimes we need to create a new variable that doesn’t exist in our dataset. For instance, we might want to figure out what decade a particular year belongs to in out babynames data and add that to our data! To create new variables, we use the function `mutate()`. \n\n* Type and run the below code in a new code chunk.\n    * Here, you are mutating a new column onto the data and storing it in the object `baby_decades`\n    * the first argument is the original data, `babynames`\n    * the second argument is the name of the new column `decade` followed by what you want in that column - the decade.\n    * we are creating the decades using the code `floor(year/10)*10. This seems complicated but it says take the year and divide by 10, then get rid of the decimal places, and then multiply by 10. So for example, 1945/10 = 194.5, and if you get rid of the decimal places that becomes 194, and multiply it by 10 gives you 1940s!.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbaby_decades <- mutate(.data = babynames,\n                  decade = floor(year/10) *10)\nbaby_decades\n```\n:::\n\n\nThe start of the data will look something like this with the new column called `decade` mutated on:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| year|sex |name      |    n|      prop| decade|\n|----:|:---|:---------|----:|---------:|------:|\n| 1880|F   |Mary      | 7065| 0.0723836|   1880|\n| 1880|F   |Anna      | 2604| 0.0266790|   1880|\n| 1880|F   |Emma      | 2003| 0.0205215|   1880|\n| 1880|F   |Elizabeth | 1939| 0.0198658|   1880|\n| 1880|F   |Minnie    | 1746| 0.0178884|   1880|\n| 1880|F   |Margaret  | 1578| 0.0161672|   1880|\n\n</div>\n:::\n:::\n\n\n\nBut mutates can be much simpler like this example here. Have a look at the code and then answer the question below:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbaby_where <- mutate(.data = babynames,\n                  country = \"USA\")\n```\n:::\n\n\nWhat will be stored in the object `baby_where`? <div class='webex-radiogroup' id='radio_XIAKHRLDRA'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XIAKHRLDRA\" value=\"\"></input> <span>a tibble with one column called country that contains the decade people were born</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XIAKHRLDRA\" value=\"answer\"></input> <span>a tibble with all the original data and a new column called country stating USA</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XIAKHRLDRA\" value=\"\"></input> <span>a tibble with all the original data and a new column stating usa</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XIAKHRLDRA\" value=\"\"></input> <span>a tibble with all the original data arranged by the country USA</span></label></div>\n\n\n\n<div class='webex-solution'><button>Explain this Answer</button>\n\nThis code will create a new object storing a tibble that has all the original data and a new column called country that states USA for each row. The `mutate()` adds to what is already there unless you add a `select()` or `filter()` to remove columns or rows. Note that one of the answers is wrong because it states usa in lowercase but the code states it in uppercase, i.e. USA. Remember to be specific.\n\n</div>\n\n\n## Test yourself {#ld-test}\n\nTo end the chapter, we have some knowledge check questions to test your understanding of the concepts we covered in the chapter. We then have some error mode tasks to see if you can find the solution to some common errors in the concepts we covered in this chapter. \n\n### Knowledge check\n\n1. Which of the following is not one of the Wickham Six functions? <div class='webex-radiogroup' id='radio_JUOPWXMRXT'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JUOPWXMRXT\" value=\"answer\"></input> <span>melt()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JUOPWXMRXT\" value=\"\"></input> <span>arrange()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JUOPWXMRXT\" value=\"\"></input> <span>mutate()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JUOPWXMRXT\" value=\"\"></input> <span>filter()</span></label></div>\n\n\n2. Which of the following functions would I use if I wanted to keep only certain columns? <div class='webex-radiogroup' id='radio_LOXRUVIKGY'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_LOXRUVIKGY\" value=\"answer\"></input> <span>select()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_LOXRUVIKGY\" value=\"\"></input> <span>arrange()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_LOXRUVIKGY\" value=\"\"></input> <span>mutate()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_LOXRUVIKGY\" value=\"\"></input> <span>filter()</span></label></div>\n\n\n3. Which of the following functions would I use if I wanted to keep only certain rows? <div class='webex-radiogroup' id='radio_IMATULPLME'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_IMATULPLME\" value=\"\"></input> <span>select()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_IMATULPLME\" value=\"\"></input> <span>arrange()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_IMATULPLME\" value=\"\"></input> <span>mutate()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_IMATULPLME\" value=\"answer\"></input> <span>filter()</span></label></div>\n\n\n4. Which of the following functions would I use if I wanted to add a new column of information? <div class='webex-radiogroup' id='radio_VVLUJCBRWM'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_VVLUJCBRWM\" value=\"\"></input> <span>select()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_VVLUJCBRWM\" value=\"\"></input> <span>arrange()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_VVLUJCBRWM\" value=\"answer\"></input> <span>mutate()</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_VVLUJCBRWM\" value=\"\"></input> <span>filter()</span></label></div>\n\n\n5. Which boolean expression would I add to a `filter()` function to keep only Male babies in the original `babynames` data? <div class='webex-radiogroup' id='radio_GINKJQXPEN'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_GINKJQXPEN\" value=\"\"></input> <span>sex == F</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_GINKJQXPEN\" value=\"answer\"></input> <span>sex == M</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_GINKJQXPEN\" value=\"\"></input> <span>sex < F</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_GINKJQXPEN\" value=\"\"></input> <span>Sex == M</span></label></div>\n\n\n\n<div class='webex-solution'><button>Explain these Answers</button>\n\n\n1. `melt()` is not a function in the Wickham six functions. It is actually a function but not one we tend to use.\n2. `select()` is the function for keeping and removing columns.\n3. `filter()` is the function for keeping and removing rows.\n4. `mutate()` is the function for adding new columns.\n5.  Assuming the original data has not been changed, `\"sex == M\"` would work and not `\"Sex == M\"` as there is no column called Sex with an uppercase S. Remember to be exact.\n\n</div>\n\n\n### Error mode\n\nThe following questions are designed to introduce you to making and fixing errors. For this topic, we focus on reading data and using ggplot2. Remember to keep a note of what kind of error messages you receive and how you fixed them, so you have a bank of solutions when you tackle errors independently. \n\nCreate and save a new R Markdown file for these activities by following the instructions in Chapter 2. You should have a blank R Markdown file below line 10. Below, we have several variations of a code chunk and inline code errors. Copy and paste them into your R Markdown file, click knit, and look at the error message you receive. See if you can fix the error and get it working before checking the answer.\n\n1. Restart the R session (**`Session >> Restart R`**). Make sure that the working directory is set to the right folder and then run the below code in your console window:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbabynames\n```\n:::\n\n\nThis will produce the error:\n\n```\nError: object 'babynames' not found\n```\n\nOnce you figure out how to fix this error, make a note of it.\n\n\n<div class='webex-solution'><button>Solution</button>\n\nThis is an indication that you have not loaded the `babynames` package into the library using the `library()` function\n\n</div>\n\n<br>\n\n2. Restart the R session (**`Session >> Restart R`**). Make sure that the working directory is set to the right folder and then run the below code in your console window:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(babynames)\n\ndat <- summarise(.data = babynames, mean_n = mean(n))\n```\n:::\n\n\nThis will produce the error:\n\n```\nError in summarise(.data = babynames, mean_n = mean(n)) : \n  could not find function \"summarise\"\n```\n\nOnce you figure out how to fix this error, make a note of it.\n\n\n<div class='webex-solution'><button>Solution</button>\n\nWhat the error is saying is that there is no function called `summarise()`. You know that function exists though. What you have not done is call load the function into the libary using `library(tidyverse)`\n\n</div>\n\n<br>\n\n3. Restart the R session (**`Session >> Restart R`**). Make sure that the working directory is set to the right folder and then run the below code in your console window:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(babynames)\nlibrary(tidyverse)\n\ndat <- summarise(.data = babynames mean_n = mean(n))\n```\n:::\n\n\nThis will produce the error:\n\n```\nError: unexpected symbol in \"dat <- summarise(.data = babynames mean_n\"\n\n```\nOnce you figure out how to fix this error, make a note of it.\n\n\n<div class='webex-solution'><button>Solution</button>\n\nThis is actually one of the most painful errors you can see as it doesn't really help you solve your issue because it is not quite clear what it means. **unexpected symbol** means effectively that the code is wrong and it is seeing something it did not think it would see. Again not that clear right? What we do when we see this is ask ourselves have we forgotten a comma somewhere or maybe a bracket or a quotation mark! Look for those issues and see if that helps. The error does show you that the error comes between `babynames` and `mean_n` it just isn't clear that that is what it means. The issue will be around the last word it mentions basically. The answer here is that there is a comma missing between the data and the arguement; between `babynames` and `mean_n`. The line should read: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(babynames)\nlibrary(tidyverse)\n\ndat <- summarise(.data = babynames, mean_n = mean(n))\n```\n:::\n\n\nAgain an incredibly frustrating and time consuming error. Watch out for these. It is why partitioning the code on to new lines after a comma can be really help see errors as such:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(babynames)\nlibrary(tidyverse)\n\ndat <- summarise(.data = babynames, \n                 mean_n = mean(n))\n```\n:::\n\n\nSuch a dastardly error! Well done if you spotted it!!!\n\n\n</div>\n\n<br>\n\n## Words from this Chapter\n\nBelow you will find a list of words that were used in this chapter that might be new to you in case it helps to have somewhere to refer back to what they mean. The links in this table take you to the entry for the words in the [PsyTeachR Glossary](https://psyteachr.github.io/glossary/){target=\"_blank\"}. Note that the Glossary is written by numerous members of the team and as such may use slightly different terminology from that shown in the chapter.\n\n\n::: {.cell layout-align=\"center\"}\n\n|term                                                  |definition                                                                                         |\n|:-----------------------------------------------------|:--------------------------------------------------------------------------------------------------|\n|[assignment-operator](https://psyteachr.github.io/glossary/a#assignment-operator){target='_blank' class='glossary'}|The symbol <-, which functions like = and assigns the value on the right to the object on the left |\n|[data-wrangling](https://psyteachr.github.io/glossary/d#data-wrangling){target='_blank' class='glossary'}|The process of preparing data for visualisation and statistical analysis.                          |\n|[function](https://psyteachr.github.io/glossary/f#function){target='_blank' class='glossary'}|A named section of code that can be reused.                                                        |\n|[inner-join](https://psyteachr.github.io/glossary/i#inner-join){target='_blank' class='glossary'}|A mutating join that returns all the rows that have a match in the other table.                    |\n|[package](https://psyteachr.github.io/glossary/p#package){target='_blank' class='glossary'}|A group of R functions.                                                                            |\n:::\n\n\n## End of Chapter\n\nThat is end of this chapter. Be sure to look again at anything you were unsure about and make some notes to help develop your own knowledge and skills. It would be good to write yourself some questions about what you are unsure of and see if you can answer them later or speak to someone about them. Good work today!\n\nBrilliant! That has been a lot of information but hopefully it has started to give you a sense of some of the approaches to data wrangling and the main functions we will use as we get deeper into the book! \n",
    "supporting": [
      "04-wrangling-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}